


'''DO NOT MODIFY THIS FILE!!!! (modify behavior_config instead)'''
'''this class is generated by a script (generate_behaviors.py) that generates a function for each behavior'''
'''changes to this file will be overwritten!'''
import logging
import util.nullhandler
import os
import inspect

logging.getLogger('Borg.Brain.AllBehaviors').addHandler(util.nullhandler.NullHandler())

class AllBehaviors(object):

    '''this class is used to call behaviors from other behaviors'''

    # storage for the instance reference
    __instance = None

    def __init__(self):
        """ Create singleton instance """
        # Check whether we already have an instance
        if AllBehaviors.__instance is None:
            AllBehaviors.__instance = AllBehaviors.__impl()# Create and remember instance


        # Store instance reference as the only member in the handle
        self.__dict__['_Singleton__instance'] = AllBehaviors.__instance


    def __getattr__(self, attr):
        """ Delegate access to implementation """
        return getattr(self.__instance, attr)

    def __setattr__(self, attr, value):
        """ Delegate access to implementation """
        return setattr(self.__instance, attr, value)


    class __impl:

        def __init__(self):
            self.logger = logging.getLogger('Borg.Brain.AllBehaviors')

        def list_module(self, name):
            mods = []
            for i in dir(name):
                item = getattr(name, i)
                if inspect.isclass(item):
                    mods.append(item)
            return mods      

        def simple_name(self, name):
            return name.lower().replace('_', '').replace('-', '')

        def __getattr__(self, attr):
            if attr in self.__dict__:
                return self.__dict__[attr]

            attr = attr.lower()
            path = os.getenv("BORG") + "/brain/src/behavior/" + attr + "/" + attr + ".py"
            init_path = os.getenv("BORG") + "/brain/src/behavior/" + attr + "/__init__.py"
            mod_path = "behavior." + attr + "." + attr

            if os.path.exists(path):
                if os.path.exists(init_path):
                    exec("import " + mod_path)
                else:
                    raise Exception("Behavior " + attr + " exists but does not have __init__.py file so it cannot be imported")
            else:
                raise Exception("Behavior " + attr + " does not exist")

            simple_name = self.simple_name(attr)

            mods = self.list_module(eval(mod_path))
            for m in mods:
                if self.simple_name(m.__name__) == simple_name:
                    self.__dict__[attr] = m
                    return m

            raise Exception("Behavior " + attr + " has no behavior selector")
